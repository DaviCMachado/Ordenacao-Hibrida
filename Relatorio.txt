Relatório do Trabalho 1 da disciplina de Pesquisa e Ordenação de Dados

Desenvolvedores: Davi de Castro Machado e Carlos Eduardo Velozo

Periodo: 2024/1.

Professor: Antonio Candia

O código será avaliado utilizando o compilador gcc com opções "-O3 -ansi"

Para a comparação de desempenho será aceito o uso de medição de tempo ou análise de complexidade - função O().


<--- Algoritmos Escolhidos --->

Algoritmo1 = KirkPatrick-Reisch (MergeSort + QuickSort)

Algoritmo2 = SpreadSort (QuickSort + RadixSort)


/-- checklist de implementações --\

o programa recebe:
(x) arquivos de texto apenas com inteiros

o programa apresenta bugs:
nao

implementado:
(x) funcao principal 1
(x) funcao principal 2
(x) funcao secundaria 1
(x) funcao secundaria 2
(1/2) diagrama de fluxo do programa
(x) mensagens de erro
(x) funciona em linux
(1/2) relatorio de comparação por tempo
(1/2) relatorio de comparação por complexidade
(0/2) explicacao dos algoritmos e seus usos

            Como compilar:
                gcc -O3 -ansi main.c -o main
            
            Como rodar:
                ./main numeros.txt

            Algoritmo1: mistura de MergeSort com QuickSort
            Algoritmo2: mistura de QuickSort com Radix Sort

            Comparamos nossos algoritmos com QuickSort 
            e Timsort (que é melhor que MergeSort em todos os casos)

            <----Comparacao por tempo, numeros aleatorios---->

            Algoritmo1:
            1k elementos: vence do  
            100k elementos: vence do Timsort e do QuickSort
            1M elementos: falta testar

            Algoritmo2:
            Vence do QuickSort e do TimSort em todos  
            tamanhos testados (Até 1M)

            <----Comparacao por tempo, numeros parcialmente ordenados---->

            Algoritmo1:
            1k elementos: falta testar 
            100k elementos: falta testar 
            1M elementos: falta testar 

            Algoritmo2:
            Vence do QuickSort e do TimSort em todos  
            tamanhos testados (Até 1M)

            <----Comparacao por tempo, muitos numeros repetidos---->

            Algoritmo1:
            1k elementos: falta testar 
            100k elementos: falta testar 
            1M elementos: falta testar 

            Algoritmo2:
            Vence do QuickSort e do TimSort em todos  
            tamanhos testados (Até 1M)


            <----Explicacao Algoritmo1---->
           
      
            <----Explicacao Algoritmo2---->

        O SpreadSort utiliza RadixSort para separar o array em buckets (arrays menores) e então utiliza o QuickSort para ordenar os elementos dentro desses buckets